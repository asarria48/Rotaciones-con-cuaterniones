# -*- coding: utf-8 -*-
"""plots_proyecto_cuaterniones

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a7R_TNN6MfuZC70hdE_W5nsqmwHNXWeJ
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import cmath
from matplotlib import animation
from IPython.display import HTML

sns.set("notebook")

#EFECTO Dzhanibekov

#Velocidades angulares con RK4 bajo las condiciones sobre las que se da el efecto dzhanibekov (SA = Solución analítica)
# Datos
datosRK4_SA1 = np.genfromtxt("DatosRK4-SA1.dat", delimiter=",")
datosRK4_w1 = np.genfromtxt("DatosRK4-w1.dat", delimiter=",")
datosRK4_w2 = np.genfromtxt("DatosRK4-w2.dat", delimiter=",")
datosRK4_SA3 = np.genfromtxt("DatosRK4-SA3.dat", delimiter=",")
datosRK4_w3 = np.genfromtxt("DatosRK4-w3.dat", delimiter=",")

# Plotear las líneas y asignar colores
plt.plot(datosRK4_w1[:, 0], datosRK4_w1[:, 1], c='r', label='RK4-w1')
plt.plot(datosRK4_w2[:, 0], datosRK4_w2[:, 1], c='black', label='RK4-w2')
plt.plot(datosRK4_w3[:, 0], datosRK4_w3[:, 1], c='orange', label='RK4-w3')

plt.title('Velocidades angulares - Efecto Dzhanibekov')
plt.xlabel('Tiempo')
plt.ylabel('$w_i$')

plt.legend()
plt.savefig("RK4.pdf")
plt.show()

#Solucion analítica

#Datos
datosRK4_SA1 = np.genfromtxt("DatosRK4-SA1.dat", delimiter=",")
datosRK4_SA3 = np.genfromtxt("DatosRK4-SA3.dat", delimiter=",")

# Plotear las líneas y asignar colores
plt.plot(datosRK4_SA1[:, 0], datosRK4_SA1[:, 1], label='RK4-SA1', color='b')
plt.plot(datosRK4_SA3[:, 0], datosRK4_SA3[:, 1], label='RK4-SA3', color='g')
plt.title('Velocidad angular - Solucion analítica')
plt.xlabel('Tiempo')
plt.ylabel('$w_i$')
plt.legend()
plt.show()

#Error relativo porcentual de las soluciones de w1 del caso anterior
plt.plot(datosRK4_w1[:,0], abs((datosRK4_SA1[:,1]-datosRK4_w1[:,1])*100/datosRK4_SA1[:,1]), c='b')
plt.savefig("error-RK-w1.pdf")
plt.title('Error porcentual de las soluciones $w_1$')
plt.xlabel('t')
plt.show()

#Error relativo porcentual de las soluciones de w3 del caso anterior
plt.plot(datosRK4_w3[:,0], abs((datosRK4_SA3[:,1]-datosRK4_w3[:,1])*100/datosRK4_SA3[:,1]), c='b')
plt.savefig("error-RK-w3.pdf")
plt.title('Error porcentual de las soluciones $w_3$')

plt.show()

#Ángulos de Euler: las cantidades que rotamos el vector

phi = 0          #Precesión
theta = np.pi  #Nutación
si = 0           #Espin


#Marices de rotación:

#Matriz de rotación de los ejes principales a los ejes normales
M = np.array([[np.cos(phi)*np.cos(si)- np.sin(phi)*np.cos(theta)*np.sin(si), -np.cos(phi)*np.sin(si) - np.sin(phi)*np.cos(theta)*np.cos(si),np.sin(phi)*np.sin(theta)],
  [np.sin(phi)*np.cos(si) + np.cos(phi)*np.cos(theta)*np.sin(si), -np.sin(phi)*np.sin(si) + np.cos(phi)*np.cos(theta)*np.cos(si), -np.cos(phi)*np.sin(theta)],
    [np.sin(theta)*np.sin(si), np.sin(theta)*np.cos(si), np.cos(theta)]])

#Matriz de rotación de los ejes de Euler a los ejes principales
A = np.array([[np.sin(theta)*np.sin(si), np.cos(si), 0],
  [np.sin(theta)*np.cos(si), -np.sin(si), 0],
    [np.cos(theta), 0, 1]])


#Funciones: las necesito para rotar un vector

#Función para crear un cuaternión
def quaternion(a, q):       #Recibe una matriz y un arreglo de 4 dimensiones

    tr = A[0][0] + A[1][1] + A[2][2]        #Traza de la matriz

    if(tr > 0):       #Si la traza es mayor que cero, puedo expresar las componentes q1, q2, y q3 dividiéndolas entre q0

      q[0] = (1/2)*np.sqrt(tr + 1)
      q[1] = (A[2][1] - A[1][2])/(4*q[0])
      q[2] = (A[0][2] - A[2][0])/(4*q[0])
      q[3] = (A[1][0] - A[0][1])/(4*q[0])


    else:             #Si la traza es menor o igual a cero, no puedo dividir entre q0 y debo expresar las componentes de otra forma

      q1 = (1/2)*np.sqrt(1 + A[0][0] - A[1][1] - A[2][2])
      q2 = (1/2)*np.sqrt(1 + A[1][1] - A[2][2] - A[0][0])
      q3 = (1/2)*np.sqrt(1 + A[2][2] - A[0][0] - A[1][1])

      c = np.array([q1, q2, q3])        #Arreglo que guarda las componentes q1, q2, y q3
      max = np.max(c)                   #Retorna la mayor componente del arreglo c

      if (max == q1):                             #Si la componente q1 es el máximo, se definen el resto de componentes de la siguiente forma:
         q[0] = (A[2][1] - A[1][2])/(4*q1)
         q[1] = q1
         q[2] = (A[1][0] + A[0][1])/(4*q1)
         q[3] = (A[0][2] + A[2][0])/(4*q1)

      else:
         if (max == q2):                          #Si la componente q2 es el máximo, se definen el resto de componentes de la siguiente forma:
            q[0] = (A[0][2] - A[2][0])/(4*q2)
            q[1] = (A[0][1] + A[1][0])/(4*q2)
            q[2] = q2
            q[3] = (A[1][2] + A[2][1])/(4*q2)

         else:
            if(max == q3):                        #Si la componente q3 es el máximo, se definen el resto de componentes de la siguiente forma:
              q[0] = (A[1][0] - A[0][1])/(4*q3)
              q[1] = (A[2][0] + A[0][2])/(4*q3)
              q[2] = (A[1][2] + A[2][1])/(4*q3)
              q[3] = q3

    return(q)        #Retorna las cuatro componentes del cuaternión


#Función que describe el producto entre cuaterniones
def product(q1, q2):        #Recibe dos cuaterniones

  b1 = np.array([q1[1], q1[2], q1[3]])                    #Parte imaginaria del cuaternión q1
  b2 = np.array([q2[1], q2[2], q2[3]])                    #Parte imaginaria del cuaternión q2
  Re = np.array(q1[0]*q2[0] - np.dot(b1,b2))            #Parte real del producto q1q2
  Im = np.array(q1[0]*b2 + q2[0]*b1 + np.cross(b1,b2))  #Parte imaginaria del producto q1q2
  q1q2 = np.array([Re, Im[0], Im[1], Im[2]])

  return(q1q2)       #Retorna el cuaternión que sale de la multiplicación de dos cuaterniones


#Función para hacer una rotación

def rotation(q, v):       #Recibe un cuaternión y un vector de la forma (0, a, b, c)

  qc = np.array([q[0],-q[1], -q[2], -q[3]])         #Cuaternión conjugado
  qv = product(q, v)                                #Multiplicación entre el cuaternión y el vector a rotar
  qvqc = product(qv,qc)                             #Multiplicación entre q y v por el cuaternión conjugado

  return(qvqc)


#Ejecución:

Q = np.zeros(4)       #Arreglo de 4 dimensiones para crear el cuaternión
q = quaternion(A,Q)   #Generador del cuaternión


#Componentes del vector a rotar en el espacio de los ángulos de Euler
phidot = 0
thetadot = np.pi
sidot = 0

v = np.array([0, phidot, thetadot, sidot])        #Vector a rotar
rv = np.array([v[1], v[2], v[3]])                 #Parte real del vector a rotar


#Rotación:

print(rotation(q,v))

datosw = np.genfromtxt("Datos-w.dat", delimiter=",");
datosq = np.genfromtxt("Datos-q.dat", delimiter=",");

def quaternion(t):
  A=int(t/0.01)
  return datosq[A,1], datosq[A,2], datosq[A,3], datosq[A,4]

#Función que describe el producto entre cuaterniones
def product(q1, q2):        #Recibe dos cuaterniones

  b1 = np.array([q1[1], q1[2], q1[3]])                    #Parte imaginaria del cuaternión q1
  b2 = np.array([q2[1], q2[2], q2[3]])                    #Parte imaginaria del cuaternión q2
  Re = np.array(q1[0]*q2[0] - np.dot(b1,b2))            #Parte real del producto q1q2
  Im = np.array(q1[0]*b2 + q2[0]*b1 + np.cross(b1,b2))  #Parte imaginaria del producto q1q2
  q1q2 = np.array([Re, Im[0], Im[1], Im[2]])

  return(q1q2)       #Retorna el cuaternión que sale de la multiplicación de dos cuaterniones


#Función para hacer una rotación

def rotation(q, v):       #Recibe un cuaternión y un vector de la forma (0, a, b, c)

  qc = np.array([q[0],-q[1], -q[2], -q[3]])         #Cuaternión conjugado
  qv = product(q, v)                                #Multiplicación entre el cuaternión y el vector a rotar
  qvqc = product(qv,qc)                             #Multiplicación entre q y v por el cuaternión conjugado

  return np.array((qvqc))

Q=quaternion(1)
V=np.array([0,1,0,0])

rotation(Q,V)

X=[]
V=np.array([0,1,0,0])
for i in datosq[:,0]:
  Q=quaternion(i)
  X.append(rotation(Q,V))

X=np.array([np.array(x) for x in X])
plt.plot(datosq[:,0], X[:,1], c='r', label='V1')
plt.plot(datosq[:,0], X[:,2], c='g', label='V2')
plt.plot(datosq[:,0], X[:,3], c='b', label='V3')

plt.title('Rotación del vector (1,0,0)')
plt.legend()
plt.show()

Y=[]
#V=np.array([0,(3)**(-0.5),(3)**(-0.5),(3)**(-0.5)])
V=np.array([0,0,1,0])
for i in datosq[:,0]:
  Q=quaternion(i)
  Y.append(rotation(Q,V))

Y=np.array([np.array(x) for x in Y])
plt.plot(datosq[:,0], Y[:,1], c='r', label='V1')
plt.plot(datosq[:,0], Y[:,2], c='g', label='V2')
plt.plot(datosq[:,0], Y[:,3], c='b', label='V3')

plt.title('Rotación del vector (0,1,0)')
plt.legend()
plt.show()

Z=[]
V=np.array([0,0,0,1])
for i in datosq[:,0]:
  Q=quaternion(i)
  Z.append(rotation(Q,V))

Z=np.array([np.array(x) for x in Z])
plt.plot(datosq[:,0], Z[:,1], c='r', label='V1')
plt.plot(datosq[:,0], Z[:,2], c='g', label='V2')
plt.plot(datosq[:,0], Z[:,3], c='b', label='V3')

plt.title('Rotación del vector (0,0,1)')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation

# Supongamos que ya tienes los datos de x, y, z a lo largo del tiempo
# Reemplaza estos arreglos con tus propios datos
x_data = Y[:,1]
y_data = Y[:,2]
z_data = Y[:,3]

# Crear la figura y el objeto de la subparcela 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Inicializar el gráfico con los datos iniciales
line, = ax.plot(x_data, y_data, z_data, label='Vector')

# Función de inicialización
def init():
    return line,

# Función de actualización para la animación
def update(frame):
    # Aquí puedes realizar cualquier operación que necesites en cada fotograma
    # Actualizar el gráfico con los datos existentes
    line.set_xdata(x_data)
    line.set_ydata(y_data)
    line.set_3d_properties(z_data)

    return line,

# Crear la animación
ani = FuncAnimation(fig, update, frames=range(100), init_func=init, interval=50, blit=True)

# Mostrar la animación
plt.show()

#SOLUCIÓN DE q GRAFICADA

import numpy as np
import matplotlib.pyplot as plt

# Datos contenidos en "Datos.dat"
datos = np.genfromtxt("Datos-q.dat", delimiter=",")
tiempo = datos[:, 0]

# Gráfica de las primeras tres columnas de "Datos.dat"
plt.plot(tiempo, datos[:, 1], label='q_0')
plt.plot(tiempo, datos[:, 2], label='q_1')
plt.plot(tiempo, datos[:, 3], label='q_2')
plt.plot(tiempo, datos[:, 4], label='q_3')

# Configuración de etiquetas y leyenda
plt.xlabel('Tiempo')
plt.ylabel('q_i')
plt.title('Cuaterniones')
plt.legend()

# Guardar el gráfico en un archivo PDF
plt.savefig("datos_grafica.pdf")
plt.show()

#SOLUCIÓN DE w GRAFICADA

import numpy as np
import matplotlib.pyplot as plt

# Datos contenidos en "Datos.dat"
datos = np.genfromtxt("Datos-w.dat", delimiter=",")
tiempo = datos[:, 0]

# Gráfica de las primeras tres columnas de "Datos.dat"
plt.plot(tiempo, datos[:, 1],label='w_1')
plt.plot(tiempo, datos[:, 2],label='w_2')
plt.plot(tiempo, datos[:, 3],label='w_3')

# Configuración de etiquetas y leyenda
plt.xlabel('Tiempo')
plt.ylabel('w_i')
plt.title('Velocidad Angular')
plt.legend()

# Guardar el gráfico en un archivo PDF
plt.savefig("datos_grafica.pdf")
plt.show()

# Coordenadas de los tres vectores en x, y, z
x_coords = np.array(X[:, 1])
y_coords = np.array(X[:, 2])
z_coords = np.array(X[:, 3])

x_coords2 = np.array(Y[:, 1])
y_coords2 = np.array(Y[:, 2])
z_coords2 = np.array(Y[:, 3])

x_coords3 = np.array(Z[:, 1])
y_coords3 = np.array(Z[:, 2])
z_coords3 = np.array(Z[:, 3])

# Factor de escala para ajustar la longitud de la flecha
scale_factor = 1.5

R = 2

# Crear la figura y los ejes 3D con un tamaño más grande
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Inicializar las flechas y agregar etiquetas
quiver1 = ax.quiver(0, 0, 0, x_coords[0] * scale_factor, y_coords[0] * scale_factor, z_coords[0] * scale_factor, color='r', arrow_length_ratio=0.1, linestyle='dashed')
label1 = ax.text(x_coords[0] * scale_factor, y_coords[0] * scale_factor, z_coords[0] * scale_factor, 'Vector 1', color='r')

quiver2 = ax.quiver(0, 0, 0, x_coords2[0] * scale_factor, y_coords2[0] * scale_factor, z_coords2[0] * scale_factor, color='b', arrow_length_ratio=0.1, linestyle='dashed')
label2 = ax.text(x_coords2[0] * scale_factor, y_coords2[0] * scale_factor, z_coords2[0] * scale_factor, 'Vector 2', color='b')

quiver3 = ax.quiver(0, 0, 0, x_coords3[0] * scale_factor, y_coords3[0] * scale_factor, z_coords3[0] * scale_factor, color='g', arrow_length_ratio=0.1, linestyle='dashed')
label3 = ax.text(x_coords3[0] * scale_factor, y_coords3[0] * scale_factor, z_coords3[0] * scale_factor, 'Vector 3', color='g')

# Esfera en el extremo del Vector 2 con radio ajustado
radius_factor = 10  # Puedes ajustar esto según tus necesidades
sphere1 = ax.scatter(x_coords2[0] * scale_factor * R, y_coords2[0] * scale_factor * R, z_coords2[0] * scale_factor * R, c='m', s=np.pi * (radius_factor ** 2), marker='o', label='Sphere 1')

sphere2 = ax.scatter(-x_coords2[0] * scale_factor * R, -y_coords2[0] * scale_factor * R, -z_coords2[0] * scale_factor * R, c='m', s=np.pi * (radius_factor ** 2), marker='o', label='Sphere 2')

sphere3 = ax.scatter(x_coords3[0] * scale_factor * R, y_coords3[0] * scale_factor * R, z_coords3[0] * scale_factor * R, c='m', s=np.pi * (4 * radius_factor ** 2), marker='o', label='Sphere 3')
sphere4 = ax.scatter(-x_coords3[0] * scale_factor * R, -y_coords3[0] * scale_factor * R, -z_coords3[0] * scale_factor * R, c='m', s=np.pi * (4 * radius_factor ** 2), marker='o', label='Sphere 4')

# Línea inicial entre las dos esferas
line, = ax.plot([x_coords2[0] * scale_factor * R, -x_coords2[0] * scale_factor * R],
                [y_coords2[0] * scale_factor * R, -y_coords2[0] * scale_factor * R],
                [z_coords2[0] * scale_factor * R, -z_coords2[0] * scale_factor * R], color='m', alpha=0.5)

# Línea suave entre las esferas 3 y 4
smooth_line, = ax.plot([], [], [], color='g', alpha=0.8)

# Función de actualización de la animación
def update(frame):
    global quiver1, quiver2, quiver3, label1, label2, label3, sphere1, sphere2, sphere3, sphere4, line, smooth_line

    quiver1.remove()
    quiver2.remove()
    quiver3.remove()
    label1.remove()
    label2.remove()
    label3.remove()

    sphere1._offsets3d = ([x_coords2[frame] * scale_factor * R], [y_coords2[frame] * scale_factor * R], [z_coords2[frame] * scale_factor * R])
    sphere2._offsets3d = ([-x_coords2[frame] * scale_factor * R], [-y_coords2[frame] * scale_factor * R], [-z_coords2[frame] * scale_factor * R])
    sphere3._offsets3d = ([x_coords3[frame] * scale_factor * R], [y_coords3[frame] * scale_factor * R], [z_coords3[frame] * scale_factor * R])
    sphere4._offsets3d = ([-x_coords3[frame] * scale_factor * R], [-y_coords3[frame] * scale_factor * R], [-z_coords3[frame] * scale_factor * R])

    line.set_xdata([x_coords2[frame] * scale_factor * R, -x_coords2[frame] * scale_factor * R])
    line.set_ydata([y_coords2[frame] * scale_factor * R, -y_coords2[frame] * scale_factor * R])
    line.set_3d_properties([z_coords2[frame] * scale_factor * R, -z_coords2[frame] * scale_factor * R])

    smooth_line.set_xdata([x_coords3[frame] * scale_factor * 2, -x_coords3[frame] * scale_factor * 2])
    smooth_line.set_ydata([y_coords3[frame] * scale_factor * 2, -y_coords3[frame] * scale_factor * 2])
    smooth_line.set_3d_properties([z_coords3[frame] * scale_factor * 2, -z_coords3[frame] * scale_factor * 2])

    quiver1 = ax.quiver(0, 0, 0, x_coords[frame] * scale_factor, y_coords[frame] * scale_factor, z_coords[frame] * scale_factor, color='r', arrow_length_ratio=0.1, linestyle='dashed')
    label1 = ax.text(x_coords[frame] * scale_factor, y_coords[frame] * scale_factor, z_coords[frame] * scale_factor, 'Vector 1', color='r')

    quiver2 = ax.quiver(0, 0, 0, x_coords2[frame] * scale_factor, y_coords2[frame] * scale_factor, z_coords2[frame] * scale_factor, color='b', arrow_length_ratio=0.1, linestyle='dashed')
    label2 = ax.text(x_coords2[frame] * scale_factor, y_coords2[frame] * scale_factor, z_coords2[frame] * scale_factor, 'Vector 2', color='b')

    quiver3 = ax.quiver(0, 0, 0, x_coords3[frame] * scale_factor, y_coords3[frame] * scale_factor, z_coords3[frame] * scale_factor, color='g', arrow_length_ratio=0.1, linestyle='dashed')
    label3 = ax.text(x_coords3[frame] * scale_factor, y_coords3[frame] * scale_factor, z_coords3[frame] * scale_factor, 'Vector 3', color='g')

    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])
    ax.set_zlim([-2, 2])

    return quiver1, quiver2, quiver3, label1, label2, label3, sphere1, sphere2, sphere3, sphere4, line, smooth_line

# Configurar la animación
ani2 = animation.FuncAnimation(fig, update, frames=len(x_coords), blit=True)

# Mostrar la animación en el notebook
HTML(ani2.to_jshtml())

ani2.save('dzhanibekov.gif', writer='pillow', fps=30)